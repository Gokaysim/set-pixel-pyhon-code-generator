from set_function import get_set_function_string, get_wait_function
from read_file import read_file
from get_frames_code import get_frames_code
from struct_generator import struct_generator
from animation_distinguisher import get_animation

if __name__ == "__main__":

    frames = read_file("./input.txt")

    p = struct_generator()
    p += get_frames_code(frames)
    p += "\nint digled_ctr = 12; // 1 init_strip + 11 LUTs for proper white color\n"
    p += get_animation()
    p += get_wait_function()
    p += get_set_function_string()

    p += "\nvoid led_matrix()"
    p += "\n{"
    p += "\n\tint nextEndFrame = endOfFramePixelIndex[0];"
    p += "\n\tshort frameIndex = 0;"
    p += "\n\tshort animationIndex = 0;"
    p += "\n\tint delay_time = AnimationFrameDelay(0);\n"
    p += "\n\t//change these 3 values depending on the loop you'd like to have"
    p += "\n\tint loop_start_point = 10695;//end of the animation before the loop starts + 1, should be 1 if the loop includes the first animation"
    p += "\n\t//if no loop, please give loop_start_point a number bigger than totalCount"
    p += "\n\tint loop_end_point = 56165;//end of the last animation in the loop"
    p += "\n\tshort loop_count = 3;//enter a number bigger than 1 in case of loops\n"
    p += "\n\t//these six are set to zero initially, will be modified automatically in the if statement below"
    p += "\n\tshort loop_start_index = 0;//loop start point in terms of total number of frames"
    p += "\n\tshort loop_end_index = 0;//loop end point in terms of total number of frames"
    p += "\n\tshort start_animation_index = 0;//loop start point in terms of total number of animations"
    p += "\n\tshort end_animation_index = 0;//loop end point in terms of total number of animations"
    p += "\n\tint frame_count_adjust = 0;//in case there is a loop, this will reduce the number of for loop iterations"
    p += "\n\tshort loop_at_end = 0;//indicates if the last animation is in the loop or not\n"
    p += "\n\tif(loop_count != 0)//to locate the start and end of the loop in frame and animation arrays"
    p += "\n\t{"
    p += "\n\t\tfor(int t = 0; t < number_of_frames; t++)"
    p += "\n\t\t{"
    p += "\n\t\t\tif(endOfFramePixelIndex[t] == loop_start_point - 1)"
    p += "\n\t\t\t{"
    p += "\n\t\t\t\tloop_start_index = t;"
    p += "\n\t\t\t}"
    p += "\n\t\t\telse if(endOfFramePixelIndex[t] == loop_end_point)"
    p += "\n\t\t\t{"
    p += "\n\t\t\t\tloop_end_index = t;"
    p += "\n\t\t\t\tbreak;"
    p += "\n\t\t\t}"
    p += "\n\t\t\telse"
    p += "\n\t\t\t\tcontinue;"
    p += "\n\t\t}\n"
    p += "\n\t\tfor(int z = 0; z < number_of_animations; z++)"
    p += "\n\t\t{"
    p += "\n\t\t\tif(animation_end_pixels[z] == loop_start_point - 1)"
    p += "\n\t\t\t{"
    p += "\n\t\t\t\tstart_animation_index = z;"
    p += "\n\t\t\t}"
    p += "\n\t\t\telse if(animation_end_pixels[z] == loop_end_point)"
    p += "\n\t\t\t{"
    p += "\n\t\t\t\tend_animation_index = z;"
    p += "\n\t\t\t\tif(z == (number_of_animations - 1))"
    p += "\n\t\t\t\t{"
    p += "\n\t\t\t\t\tloop_at_end = 1;"
    p += "\n\t\t\t\t}"
    p += "\n\t\t\t\telse"
    p += "\n\t\t\t\t{"
    p += "\n\t\t\t\t\tloop_at_end = 0;"
    p += "\n\t\t\t\t}"
    p += "\n\t\t\t\tbreak;"
    p += "\n\t\t\t}"
    p += "\n\t\t\telse"
    p += "\n\t\t\t\tcontinue;"
    p += "\n\t\t}\n"
    p += "\n\t\tframe_count_adjust = loop_end_point - loop_start_point + 1 - (2 * loop_at_end);"
    p += "\n\t}"
    p += "\n\telse"
    p += "\n\t\tframe_count_adjust = 0;\n"
    p += "\n\tfor(int i = 0; i < totalCount - frame_count_adjust; i++)"
    p += "\n\t{"
    p += "\n\t\tif(loop_start_point > i)//before the loop starts"
    p += "\n\t\t{"
    p += "\n\t\t\tdelay_time = AnimationFrameDelay(animationIndex);"
    p += "\n\t\t\tif(i == nextEndFrame)"
    p += "\n\t\t\t{"
    p += "\n\t\t\t\tframeIndex += 1;"
    p += "\n\t\t\t\tnextEndFrame = endOfFramePixelIndex[frameIndex];"
    p += "\n\t\t\t\tif(i == animation_end_pixels[animationIndex])"
    p += "\n\t\t\t\t{"
    p += "\n\t\t\t\t\twait(8000000);"
    p += "\n\t\t\t\t\tanimationIndex++;"
    p += "\n\t\t\t\t}"
    p += "\n\t\t\t\telse"
    p += "\n\t\t\t\t{"
    p += "\n\t\t\t\t\twait(delay_time);"
    p += "\n\t\t\t\t}"
    p += "\n\t\t\t}"
    p += "\n\t\t\tsetPixel((int)changedPixels[i].r, (int)changedPixels[i].g, (int)changedPixels[i].b, changedPixels[i].addr);"
    p += "\n\t\t}"
    p += "\n\t\telse"
    p += "\n\t\t{"
    p += "\n\t\t\tif(i == loop_start_point) // loop starts"
    p += "\n\t\t\t{"
    p += "\n\t\t\t\twhile(loop_count > 0)"
    p += "\n\t\t\t\t{"
    p += "\n\t\t\t\t\tfor(int j = loop_start_point - 1; j < loop_end_point; j++)"
    p += "\n\t\t\t\t\t{"
    p += "\n\t\t\t\t\t\tsetPixel((int)changedPixels[j].r, (int)changedPixels[j].g, (int)changedPixels[j].b, changedPixels[j].addr);\n"
    p += "\n\t\t\t\t\t\tfor(int a = 0; a < end_animation_index - start_animation_index; a++)"
    p += "\n\t\t\t\t\t\t{"
    p += "\n\t\t\t\t\t\t\tif(animation_end_pixels[a + start_animation_index] == j)//end of animations within the loop"
    p += "\n\t\t\t\t\t\t\t\tdelay_time = AnimationFrameDelay(animationIndex + a);"
    p += "\n\t\t\t\t\t\t}\n"
    p += "\n\t\t\t\t\t\tfor(int k = loop_start_index; k <= loop_end_index; k++)"
    p += "\n\t\t\t\t\t\t{"
    p += "\n\t\t\t\t\t\t\tif(endOfFramePixelIndex[k] == j)//end of frames within the loop"
    p += "\n\t\t\t\t\t\t\t\twait(delay_time);"
    p += "\n\t\t\t\t\t\t}"
    p += "\n\t\t\t\t\t}\n"
    p += "\n\t\t\t\t\tif(loop_count == 1)"
    p += "\n\t\t\t\t\t{"
    p += "\n\t\t\t\t\t\tloop_start_point = 0;"
    p += "\n\t\t\t\t\t\tframeIndex = frameIndex + loop_end_index - loop_start_index + 1;"
    p += "\n\t\t\t\t\t\tanimationIndex = animationIndex + end_animation_index - start_animation_index;"
    p += "\n\t\t\t\t\t\tnextEndFrame = endOfFramePixelIndex[frameIndex];"
    p += "\n\t\t\t\t\t}\n"
    p += "\n\t\t\t\t\tif(end_animation_index - start_animation_index != 1)//if the addresses of activated LEDs within the looped single animation are not changing at each frame"
    p += "\n\t\t\t\t\t{													//use this if, otherwise just use the for loop in the brackets and remove the if statement"
    p += "\n\t\t\t\t\t\tfor(int c = 0; c < 2100; c++)//to clean the screen when the loop repeats itself"
    p += "\n\t\t\t\t\t\t{"
    p += "\n\t\t\t\t\t\t\tsetPixel(0, 0, 0, c);"
    p += "\n\t\t\t\t\t\t}"
    p += "\n\t\t\t\t\t}\n"
    p += "\n\t\t\t\t\tloop_count--;"
    p += "\n\t\t\t\t}"
    p += "\n\t\t\t}"
    p += "\n\t\t\telse//the part after loop"
    p += "\n\t\t\t{"
    p += "\n\t\t\t\tdelay_time = AnimationFrameDelay(animationIndex);"
    p += "\n\t\t\t\tif(i + frame_count_adjust == nextEndFrame)"
    p += "\n\t\t\t\t{"
    p += "\n\t\t\t\t\tframeIndex += 1;"
    p += "\n\t\t\t\t\tnextEndFrame = endOfFramePixelIndex[frameIndex];"
    p += "\n\t\t\t\t\tif(i + frame_count_adjust == animation_end_pixels[animationIndex])"
    p += "\n\t\t\t\t\t{"
    p += "\n\t\t\t\t\t\twait(5000000);"
    p += "\n\t\t\t\t\t\tanimationIndex++;"
    p += "\n\t\t\t\t\t}"
    p += "\n\t\t\t\t\telse"
    p += "\n\t\t\t\t\t{"
    p += "\n\t\t\t\t\t\twait(delay_time);"
    p += "\n\t\t\t\t\t}"
    p += "\n\t\t\t\t}"
    p += "\n\t\t\t\tsetPixel((int)changedPixels[i + frame_count_adjust].r, (int)changedPixels[i + frame_count_adjust].g, (int)changedPixels[i + frame_count_adjust].b, changedPixels[i + frame_count_adjust].addr);"
    p += "\n\t\t\t}"
    p += "\n\t\t}"
    p += "\n\t}"
    p += "\n\twait(10000000);//extra delay before the LED show starts again"
    p += "\n}"

    f = open("./program.c", "w")

    f.write(p)

    f.close()
