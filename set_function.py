def get_set_function_string():
    s = "\nvoid setPixel(int r, int g, int b, int addr)"
    s += "\n{"
    s += "\n\tif(digled_ctr == 8402) // refresh the NXP MCU counter before it reaches 10k"
    s += "\n\t{"
    s += "\n\t\tdigLED_Init_Interface(NUMBER_OF_INTERFACES, iseled1_InitConfig);"
    s += "\n\t\tdelay(10000);"
    s += "\n\t\tdigLED_Init_Strip(&testInitType, &digLEDResultStrip1, strip);"
    s += "\n\t\tdelay(10000);"
    s += "\n\t\tdigled_ctr = 2;"
    s += "\n\t}"
    s += "\n\tSet_RGB_Params.Red = r;"
    s += "\n\tSet_RGB_Params.Green = g;"
    s += "\n\tSet_RGB_Params.Blue = b;"
    s += "\n\tdigLED_Set_RGB(Set_RGB_Params.Red, Set_RGB_Params.Green, Set_RGB_Params.Blue, addr, strip);"
    s += "\n\tdigled_ctr = 2;"
    s += "\n\twait(1000);"
    s += "\n}\n"
    return s


def get_wait_function():
    s = "\nvoid wait(int d)"
    s += "\n{"
    s += "\n\tdelay(d);"
    s += "\n\tiseled_reset_counter++;"
    s += "\n\tif (iseled_reset_counter == 10000)"
    s += "\n\t\tiseled_reset();"
    s += "\n}\n"
    return s


def get_led_matrix():
    s = "\nvoid led_matrix(animationTypes animation, short loop_count, int delay_after_animation)"
    s += "\n{"
    s += "\n\tshort frameIndex = 0;"
    s += "\n\tshort loopstart_frameIndex = 0; //to save the place where loop starts"
    s += "\n\tshort animationIndex = (animation.animation_order) - 1;"
    s += "\n\tint delay_frames = AnimationFrameDelay(animationIndex);\n"
    s += "\n\tint nextEndFrame;"
    s += "\n\tint start_point = animation.animation_start_point;"
    s += "\n\tint end_point = animation.animation_end_point;\n"
    s += "\n\tif(start_point != 0)"
    s += "\n\t{"
    s += "\n\t\tstart_point = animation.animation_start_point - 1;"
    s += "\n\t\tfor(int i = 0; i < number_of_animations; i++)"
    s += "\n\t\t{"
    s += "\n\t\t\tfor(int j = 0; j < number_of_frames; j++)"
    s += "\n\t\t\t{"
    s += "\n\t\t\t\tif(endOfFramePixelIndex[j] == animation.animation_start_point - 1)"
    s += "\n\t\t\t\t{"
    s += "\n\t\t\t\t\tframeIndex = j;"
    s += "\n\t\t\t\t\tloopstart_frameIndex = j;"
    s += "\n\t\t\t\t\tbreak;"
    s += "\n\t\t\t\t}"
    s += "\n\t\t\t}"
    s += "\n\t\t}"
    s += "\n\t}\n"
    s += "\n\tnextEndFrame = endOfFramePixelIndex[frameIndex];\n"
    s += "\n\twhile(loop_count > 0)"
    s += "\n\t{"
    s += "\n\t\tfor(int i = start_point; i < end_point; i++)"
    s += "\n\t\t{"
    s += "\n\t\t\tif(i == nextEndFrame)"
    s += "\n\t\t\t{"
    s += "\n\t\t\t\tframeIndex += 1;"
    s += "\n\t\t\t\tnextEndFrame = endOfFramePixelIndex[frameIndex];"
    s += "\n\t\t\t\tif(i != end_point)"
    s += "\n\t\t\t\t{"
    s += "\n\t\t\t\t\twait(delay_frames);"
    s += "\n\t\t\t\t}"
    s += "\n\t\t\t}"
    s += "\n\t\t\tsetPixel((int)changedPixels[i].r, (int)changedPixels[i].g, (int)changedPixels[i].b, changedPixels[i].addr);"
    s += "\n\t\t}"
    s += "\n\t\tloop_count--;"
    s += "\n\t\tif(loop_count == 0)"
    s += "\n\t\t\twait(delay_after_animation);"
    s += "\n\t\tframeIndex = loopstart_frameIndex; // to start the loop once again"
    s += "\n\t\tnextEndFrame = endOfFramePixelIndex[frameIndex];"
    s += "\n\t}"
    s += "\n}\n"
    return s
